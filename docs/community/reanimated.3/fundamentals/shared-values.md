---
description: Общие значения (Shared Values) являются одной из фундаментальных концепций Reanimated
---

# Общие значения

**Общие значения** (Shared Values) являются одной из фундаментальных концепций Reanimated.
Если вы знакомы с [Animated API](../../../rn/animated.md) React Native, то можете сравнить их с `Animated.Values`.

Они выполняют аналогичные функции: переносят "одушевляемые" данные, обеспечивают понятие реактивности и управляют анимацией.

Ниже мы рассмотрим каждую из этих ключевых ролей Shared Values. В конце мы представим краткий обзор различий между Shared Values и `Animated.Value` для читателей, знакомых с API `Animated`.

## Перенос данных

Одна из основных целей Shared Values - предоставить понятие общей памяти в Reanimated (отсюда и их название).

Как вы уже могли узнать из статьи о [worklets](worklets.md), Reanimated выполняет код анимации в отдельном потоке, используя отдельный контекст JS VM. Shared Values позволяют хранить ссылки на мутируемые данные, которые можно безопасно читать и изменять в этих потоках.

Объекты Shared Value служат ссылками на фрагменты общих данных, доступ к которым и их изменение возможны с помощью свойства `.value`. Важно помнить, что для доступа или обновления общих данных необходимо использовать свойство `.value` (один из наиболее распространенных источников ошибок в коде Reanimated - ожидание, что ссылка на Shared Value вернет данные, а не обращение к свойству `.value`).

Для того чтобы обеспечить безопасный и быстрый доступ к общим данным в двух потоках, при разработке Shared Values пришлось пойти на некоторые компромиссы.

Поскольку во время анимации обновления чаще всего происходят в потоке UI, Shared Values оптимизированы для обновления и чтения из потока UI. Таким образом, чтение и запись из потока UI являются синхронными, что означает, что при запуске из воркета в потоке UI можно обновить значение и ожидать, что оно будет обновлено сразу после этого вызова. Следствием такого выбора является то, что обновления, выполняемые в потоке React Native JS, являются асинхронными.

Вместо немедленного обновления в этом случае ядро Reanimated планирует обновление в потоке UI, что позволяет избежать проблем с параллелизмом. При обращении к общим значениям и их обновлении из потока React Native JS лучше всего думать о том, что значение работает так же, как и состояние React. Мы можем обновлять состояние, но обновления происходят не сразу, и для того, чтобы прочитать данные, необходимо дождаться следующего рендеринга.

Для того чтобы создать ссылку на Shared Value, необходимо использовать хук `useSharedValue`:

```js
const sharedVal = useSharedValue(3.1415);
```

Конструктор Shared Value принимает один аргумент, который является начальной полезной нагрузкой Shared Value. Это могут быть любые примитивные или вложенные данные, такие как объект, массив, число, строка или булево.

Для обновления Shared Value из потока React Native или из воркета, запущенного в потоке UI, необходимо установить новое значение в свойство `.value`.

```js
import { useSharedValue } from 'react-native-reanimated';

function SomeComponent() {
    const sharedVal = useSharedValue(0);
    return (
        <Button
            onPress={() =>
                (sharedVal.value = Math.random())
            }
            title="Randomize"
        />
    );
}
```

В приведенном выше примере мы обновляем значение асинхронно из потока React Native JS.
Обновления можно выполнять синхронно, если делать их изнутри воркета, например, так:

```js
import Animated, {
    useSharedValue,
    useAnimatedScrollHandler,
} from 'react-native-reanimated';

function SomeComponent({ children }) {
    const scrollOffset = useSharedValue(0);

    const scrollHandler = useAnimatedScrollHandler({
        onScroll: (event) => {
            scrollOffset.value = event.contentOffset.y;
        },
    });

    return (
        <Animated.ScrollView onScroll={scrollHandler}>
            {children}
        </Animated.ScrollView>
    );
}
```

Выше обработчик прокрутки является воркетом и выполняет логику события прокрутки в потоке UI.
Обновления, выполняемые в этом ворклете, являются синхронными.

## Реактивность с помощью Shared Values

Второй важнейший аспект Shared Values заключается в том, что они обеспечивают понятие реактивности для фреймворка Reanimated. Под этим мы понимаем, что обновление Shared Values может инициировать выполнение соответствующего кода в потоке UI, что в дальнейшем может привести к запуску анимации, обновлению вида и т.д.

Слой реактивности спроектирован таким образом, чтобы быть полностью прозрачным с точки зрения разработчика. В его основе лежит концепция захвата общих значений реактивными рабочими элементами (называемыми внутри компании "mapper worklets").

В настоящее время существует два способа создания реактивного рабочего модуля. Это можно сделать либо с помощью хуков [`useAnimatedStyle`](../api/hooks/useAnimatedStyle.md), либо с помощью хука [`useDerivedValue`](../api/hooks/useDerivedValue.md). Когда Shared Value перехватывается заготовкой, связанной с этими хуками, заготовка будет перезапускаться при изменении Shared Value.

Под капотом движок Reanimated строит граф зависимостей между Shared Value и реактивными ворклетами, что позволяет нам выполнять только тот код, который нуждается в обновлении, и следить за тем, чтобы обновления происходили в правильном порядке.

Например, если у нас есть общее значение `x`, производное значение `y`, которое использует `x`, и анимированный стиль, который использует и `x`, и `y`, мы повторно запускаем ворклет производного значения только после обновления `x`.

В этом случае мы также всегда будем сначала запускать апдейтер производного значения `y`, а затем апдейтер анимированного стиля, поскольку стиль зависит от него.

Теперь рассмотрим пример кода:

```js
import Animated, {
    useSharedValue,
    useAnimatedStyle,
} from 'react-native-reanimated';

function Box() {
    const offset = useSharedValue(0);

    const animatedStyles = useAnimatedStyle(() => {
        return {
            transform: [{ translateX: offset.value }],
        };
    });

    return (
        <>
            <Animated.View
                style={[styles.box, animatedStyles]}
            />
            <Button
                onPress={() =>
                    (offset.value = Math.random() * 255)
                }
                title="Move"
            />
        </>
    );
}
```

В приведенном выше коде мы определяем общее значение `offset`, которое используется внутри реактивного заготовки `useAnimatedStyle`. Изначально значение `offset` Shared Value установлено в `0`, и мы добавили кнопку, которая обновляет это значение с помощью `Math.random()`.

Таким образом, при каждом нажатии на кнопку значение `offset` будет обновляться до случайного значения от `0` до `1`. Поскольку заготовки в анимированном стиле являются реактивными, а в нашем случае они зависят от единственной общей переменной `offset`, заготовка не будет выполняться, кроме как при первоначальном запуске, или если значение не будет обновлено. При нажатии кнопки и обновлении значения ядро Reanimated выполнит зависимые от него заготовки. В нашем случае это будет заготовка анимированного стиля.

В результате этот воркет будет повторно выполнен, что приведет к обновлению стиля. Поскольку в `useAnimatedStyle` мы берем значение `offset`, умножаем его на `255` и сопоставляем с x-трансляцией вида, вид сразу же будет смещен в новое место, удаленное от `0` до `255` пикселей от начальной позиции вида.

Именно это вы и будете наблюдать:

![Реактивность с помощью Shared Values](sv-immediate.gif)

## Запуск анимаций

Анимации в Reanimated являются первоклассными гражданами, и библиотека поставляется с рядом вспомогательных методов, которые помогают запускать и настраивать анимации (обратитесь к разделу [animations](animations.md), чтобы узнать об API в Reanimated для управления анимациями).
Одним из способов запуска анимации является запуск анимированного перехода Shared Value.
Это можно сделать, обернув целевое значение одним из методов анимации из библиотеки Reanimated (например, [`withTiming`](../api/animations/withTiming.md) или [`withSpring`](../api/animations/withSpring.md)):

```js
import { withTiming } from 'react-native-reanimated';

someSharedValue.value = withTiming(50);
```

В приведенном выше коде общее значение `offset` вместо того, чтобы сразу установиться в `50`, будет переходить от текущего значения к `50` с помощью анимации, основанной на времени.

Разумеется, запускать анимацию таким образом можно как из пользовательского интерфейса, так и из JS-потока React Native. Ниже приведен полный пример кода, который является модифицированной версией примера из предыдущего раздела.

Здесь вместо немедленного обновления значения `offset` мы выполняем анимированный переход с помощью кривой времени.

```js
import Animated, {
    withSpring,
} from 'react-native-reanimated';

function Box() {
    const offset = useSharedValue(0);

    const animatedStyles = useAnimatedStyle(() => {
        return {
            transform: [{ translateX: offset.value }],
        };
    });

    return (
        <>
            <Animated.View
                style={[styles.box, animatedStyles]}
            />
            <Button
                onPress={() => {
                    offset.value = withSpring(
                        Math.random() * 255
                    );
                }}
                title="Move"
            />
        </>
    );
}
```

Единственное изменение, которое мы сделали в приведенном коде по сравнению с примером из предыдущего раздела, - это обернули вызов `Math.random()`, обновляющий `offset`, вызовом `withSpring`.

В результате обновление трансляции представления будет происходить плавно:

![Запуск анимаций](sv-spring.gif)

Если вы хотите узнать, как настроить анимацию или получить уведомление о ее завершении, обратитесь к API метода анимации, который вы хотите использовать, например, [`withTiming`](../api/animations/withTiming) или [`withSpring`](../api/animations/withSpring).

### Прогресс анимации

Для получения текущего состояния анимированного перехода, запущенного на Shared Value, мы можем обратиться к свойству `.value` Shared Value. После запуска перехода Shared Value свойство `.value` будет синхронизировано с прогрессом анимации.

То есть, если начальное значение равно `0` и мы запускаем анимированный переход с помощью `withTiming(50)`, который займет 300 мс, то следует ожидать, что чтение свойства `.value` вернет число от `0` до `50`, которое будет соответствовать текущему положению значения по мере выполнения анимации.

### Прерывание анимации

Благодаря тому, что Shared Values сохраняют состояние своего анимированного перехода, мы можем сделать все анимации полностью прерываемыми.

Это означает, что можно вносить изменения в Shared Value, даже если в данный момент выполняется анимация, не опасаясь, что это приведет к неожиданному и внезапному сбою анимации. Перезапись значения в этом случае приведет к прерыванию предыдущей анимации.

Если вновь присвоенное значение является числом (или чем-либо статическим), то это новое значение будет немедленно присвоено Shared Value, а ранее запущенная анимация будет отменена.

Если же вновь присвоенное значение также является анимацией, то ранее запущенная анимация плавно перейдет в новую. При этом будут передаваться и такие параметры анимации, как скорость, что особенно важно для анимаций, основанных на пружинах.

Это позволяет добиться действительно плавного перехода от одной анимации к другой. Это поведение демонстрируется в приведенном ниже ролике, где мы просто делаем более частые нажатия на кнопку, в результате чего новая анимация запускается в то время, когда предыдущая еще работает (никаких изменений в коде по сравнению с предыдущим примером нет).

![Прерывание анимации](sv-interruption.gif)

### Отмена анимации

Бывают случаи, когда необходимо остановить текущую анимацию, не запуская новую. В reanimated это можно сделать с помощью метода [`cancelAnimation`](../api/animations/cancelAnimation.md):

```js
import { cancelAnimation } from 'react-native-reanimated';

cancelAnimation(someSharedValue);
```

Animations can be cancelled both from the UI and from React Native's JS thread.

## Shared Values против Animated.Value

В этом разделе мы приводим краткое описание различий между Shared Values и Animated.Values.

Цель этого сравнения - не указать на недостатки одного решения по сравнению с другим, а предоставить краткую справку для тех, кто знаком с `Animated`.

Если вас смущают какие-то аспекты Shared Values и вы ожидаете, что они будут работать аналогично Animated Values, пожалуйста, сообщите нам об этом, и мы добавим это в список.

| Действие                | Animated Value                                                                                                                                                  | Shared Value                                                                                                                                                                                                                                                                                                               |
| ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Полезная нагрузка       | Поддерживаются только числовые и строковые значения                                                                                                             | Любая примитивная или вложенная структура данных (например, объекты, массивы, строки, числа, булевы).                                                                                                                                                                                                                      |
| Связь с пропсами `View` | Передача `Animated.Value` непосредственно в качестве пропса                                                                                                     | Shared Values не могут быть напрямую подключены в качестве пропсов `View`. Вы должны использовать `useAnimatedStyle` или `useAnimatedProps`, где вы можете получить доступ к Shared Values и вернуть их как выбранные стили/пропсы или обработать их для вычисления стилей.                                                |
| Обновление значений     | С помощью метода `value.setValue` (который является асинхронным вызовом, если значение использует родной драйвер)                                               | Путем обновления свойства `.value`. Обновление свойства `.value` происходит синхронно, если оно выполняется в потоке UI, или асинхронно, если оно выполняется в потоке React Native JS.                                                                                                                                    |
| Чтение значений         | Зарегистрируйте слушателя с помощью `value.addListener`, чтобы получать все обновления анимированных значений.                                                  | С помощью чтения свойства `.value` можно получить доступ к текущему значению, хранящемуся в Shared Value (как из пользовательского интерфейса, так и из потока React Native JS).                                                                                                                                           |
| Запуск анимации         | Для запуска анимации используйте `Animated.spring`, `Animated.timing` (или другие), передайте в качестве аргумента Animated Value и запустите метод `.start()`. | Обновляйте пропс `.value` как обычно, обернув цель одним из вспомогательных методов анимации (например, `withTiming`).                                                                                                                                                                                                     |
| Остановка анимации      | Удерживайте ссылку на объект анимации, возвращаемый `Animated.timing` и подобными методами, а затем вызывайте для него метод `stopAnimation()`.                 | Используйте метод `cancelAnimation` и передайте ему общее значение, которое запускает анимацию.                                                                                                                                                                                                                            |
| Интерполяция            | Используйте метод-член `interpolate()` для Animated Value.                                                                                                      | Используйте метод `interpolate`, который принимает число и конфигурируется аналогично методу Animated's interpolate, а затем возвращает интерполированное число. Это можно использовать вместе с `useDerivedValue`, если вам нужно общее значение, которое автоматически отслеживает интерполяцию другого общего значения. |

## Ссылки

-   [Shared Values](https://docs.swmansion.com/react-native-reanimated/docs/fundamentals/shared-values/)
