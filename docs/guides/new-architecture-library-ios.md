# Включение в библиотеке iOS

!!!warning "Внимание"

    Эта документация все еще является экспериментальной, и детали могут быть изменены по мере итераций. Не стесняйтесь делиться своими отзывами в обсуждении внутри рабочей группы для этой страницы.

    Более того, она содержит несколько ручных шагов. Пожалуйста, обратите внимание, что это не будет представлять окончательный опыт разработчиков, когда Новая архитектура станет стабильной. Мы работаем над инструментами, шаблонами и библиотеками, которые помогут вам быстро начать работу с новой архитектурой без необходимости проходить всю процедуру настройки.

Вы определили спецификации JavaScript для своих родных модулей в рамках [предварительных условий](new-architecture-library-intro.md), и теперь вы готовы перенести свою библиотеку на новую архитектуру. Вот шаги, которые вы можете выполнить для этого.

## 1. Обновление вашего Podspec для новой архитектуры

Новая архитектура использует CocoaPods.

### Добавление Folly и других зависимостей

Новая архитектура требует некоторых специфических зависимостей для правильной работы. Вы можете настроить свой podspec на автоматическую установку необходимых зависимостей, изменив файл `.podspec`. В блоке `Pod::Spec.new` добавьте следующую строку:

```diff
Pod::Spec.new do |s|
  # ...
+  install_modules_dependencies(s)
  # ...
end
```

По этой [ссылке](https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L192-L197) вы можете найти документацию функции `install_modules_dependencies`.

Если вам нужно явно знать, какие `folly_flags` использует React Native, вы можете запросить их с помощью функции [`folly_flag`](https://github.com/facebook/react-native/blob/main/packages/react-native/scripts/react_native_pods.rb#L188).

## 2. Расширение или реализация нативных интерфейсов, генерируемых кодом

Спецификация JavaScript для вашего нативного модуля или компонента будет использоваться для генерации кода нативного интерфейса для каждой поддерживаемой платформы (т.е. Android и iOS). Эти файлы нативных интерфейсов будут генерироваться при создании приложения React Native, зависящего от вашей библиотеки.

Хотя сгенерированный код нативного интерфейса **не будет поставляться как часть вашей библиотеки**, вам необходимо убедиться, что ваш код Objective-C или Java соответствует протоколам, предоставляемым этими файлами нативного интерфейса. Вы можете использовать сценарий Codegen для генерации кода родного интерфейса вашей библиотеки, чтобы использовать его **в качестве ссылки**.

```sh
cd <path/to/your/app>
node node_modules/react-native/scripts/generate-codegen-artifacts.js \
    --path <your app>/ \
    --outputPath <an/output/path> \
```

Эта команда сгенерирует код шаблона, требуемый iOS, по пути вывода, указанному в качестве параметра.

Файлы, выводимые скриптом, **не должны быть зафиксированы**, но вам нужно будет обратиться к ним, чтобы определить, какие изменения нужно внести в ваши родные модули, чтобы они обеспечили реализацию каждого сгенерированного `@протокола` / родного интерфейса.

### Соответствие протоколам, предоставляемым кодом нативного интерфейса

Обновите ваш нативный модуль или компонент, чтобы убедиться, что он реализует/расширяет нативный интерфейс, который был сгенерирован из ваших спецификаций JavaScript.

Следуя примеру, изложенному в предыдущем разделе, ваша библиотека может импортировать `MyAwesomeSpecs.h`, расширить соответствующий собственный интерфейс и реализовать необходимые методы для этого интерфейса:

```objc
#import <MyAwesomeSpecs/MyAwesomeSpecs.h>

@interface MyAwesomeModule () <StringGetterSpec>
@end

RCT_EXPORT_METHOD(getString:(NSString *)string
                   callback:(RCTResponseSenderBlock)callback)
{
  // Implement this method
}

- (std::shared_ptr<TurboModule>)getTurboModule:(const ObjCTurboModule::InitParams &)params
{
  return std::make_shared<StringGetterSpecJSI>(params);
}
```

Для существующего нативного модуля у вас, скорее всего, уже есть один или несколько экземпляров [`RCT_EXPORT_METHOD`](native-modules-ios.md#export-a-native-method-to-javascript). Чтобы перейти на новую архитектуру, вам нужно убедиться, что сигнатура метода использует структуры, предоставляемые при выводе Codegen.
