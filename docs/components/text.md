# Text

Компонент React для отображения текста.

`Text` поддерживает вложенность, стилизацию и обработку касаний.

В следующем примере вложенные заголовок и основной текст наследуют `fontFamily` от `styles.baseText`, но заголовок предоставляет свои собственные дополнительные стили. Заголовок и тело будут накладываться друг на друга из-за буквальных новых строк:

<div data-snack-id="@bndby/text-functional-component-example" data-snack-platform="web" data-snack-preview="true" data-snack-theme="light" style="overflow:hidden;background:#F9F9F9;border:1px solid var(--color-border);border-radius:4px;height:505px;width:100%"></div>

## Вложенный текст

И Android, и iOS позволяют отображать форматированный текст путем аннотирования диапазонов строки с определенным форматированием, например, жирным или цветным текстом (`NSAttributedString` на iOS, `SpannableString` на Android). На практике это очень утомительно. В React Native мы решили использовать для этого веб-парадигму, где вы можете вложить текст для достижения того же эффекта.

<div data-snack-id="@bndby/nested-text-example" data-snack-platform="web" data-snack-preview="true" data-snack-theme="light" style="overflow:hidden;background:#F9F9F9;border:1px solid var(--color-border);border-radius:4px;height:505px;width:100%"></div>

За кулисами React Native преобразует это в плоскую `NSAttributedString` или `SpannableString`, которая содержит следующую информацию:

```
"I am bold and red"
0-9: bold
9-17: bold, red
```

## Контейнеры

Элемент `<Text>` уникален с точки зрения компоновки: все, что находится внутри него, больше не использует компоновку Flexbox, а использует компоновку текста. Это означает, что элементы внутри `<Text>` больше не являются прямоугольниками, а заворачиваются, когда видят конец строки.

```ts
<Text>
  <Text>First part and </Text>
  <Text>second part</Text>
</Text>
// Text container: the text will be inline if the space allowed it
// |First part and second part|

// otherwise, the text will flow as if it was one
// |First part |
// |and second |
// |part       |

<View>
  <Text>First part and </Text>
  <Text>second part</Text>
</View>
// View container: each text is its own block
// |First part and|
// |second part   |

// otherwise, the text will flow in its own block
// |First part |
// |and        |
// |second part|
```

## Ограниченное наследование стиля

В Интернете обычный способ установить семейство и размер шрифта для всего документа — это воспользоваться унаследованными свойствами CSS, например, такими:

```css
html {
    font-family: 'lucida grande', tahoma, verdana, arial,
        sans-serif;
    font-size: 11px;
    color: #141823;
}
```

Все элементы в документе наследуют этот шрифт, если только они или один из их родителей не укажет новое правило.

В React Native мы более строги к этому: **Вы должны обернуть все текстовые узлы внутри компонента `<Text>`**. Вы не можете располагать текстовый узел непосредственно под `<View>`.

```ts
// BAD: will raise exception, can't have a text node as child of a <View>
<View>
  Some text
</View>

// GOOD
<View>
  <Text>
    Some text
  </Text>
</View>
```

Вы также теряете возможность установить шрифт по умолчанию для всего поддерева. Между тем, `fontFamily` принимает только одно имя шрифта, что отличается от `font-family` в CSS. Рекомендуемый способ использования согласованных шрифтов и размеров в приложении — создать компонент `MyAppText`, который включает их, и использовать этот компонент в приложении. Вы также можете использовать этот компонент для создания более специфических компонентов, таких как `MyAppHeaderText`, для других видов текста.

```ts
<View>
    <MyAppText>
        Text styled with the default font for the entire
        application
    </MyAppText>
    <MyAppHeaderText>
        Text styled as a header
    </MyAppHeaderText>
</View>
```

Если предположить, что `MyAppText` — это компонент, который только рендерит свои дочерние элементы в компонент `Text` со стилизацией, то `MyAppHeaderText` можно определить следующим образом:

```ts
class MyAppHeaderText extends Component {
    render() {
        return (
            <MyAppText>
                <Text style={{ fontSize: 20 }}>
                    {this.props.children}
                </Text>
            </MyAppText>
        );
    }
}
```

Составление `MyAppText` таким образом гарантирует, что мы получим стили от компонента верхнего уровня, но оставляет нам возможность добавлять / переопределять их в конкретных случаях использования.

В React Native все еще существует концепция наследования стилей, но она ограничена текстовыми поддеревьями. В данном случае вторая часть будет и жирной, и красной.

```ts
<Text style={{ fontWeight: 'bold' }}>
    I am bold
    <Text style={{ color: 'red' }}>and red</Text>
</Text>
```

Мы считаем, что такой более ограниченный способ стилизации текста позволит создавать более качественные приложения:

-   (Разработчик) Компоненты React разработаны с учетом сильной изоляции: Вы должны иметь возможность поместить компонент в любое место вашего приложения, будучи уверенным, что до тех пор, пока реквизиты одинаковы, он будет выглядеть и вести себя одинаково. Свойства текста, которые могут быть унаследованы от других реквизитов, нарушат эту изоляцию.

-   (Реализатор) Реализация React Native также упрощена. Нам не нужно иметь поле `fontFamily` на каждом отдельном элементе, и нам не нужно потенциально обходить дерево до корня каждый раз, когда мы отображаем текстовый узел. Наследование стиля кодируется только в родном компоненте Text и не просачивается в другие компоненты или саму систему.

## Реквизиты

### `accessibilityHint`

Подсказка доступности помогает пользователям понять, что произойдет, когда они выполнят действие над элементом доступности, если результат не ясен из метки доступности.

| Type   |
| ------ |
| string |

### `accessibilityLanguage` :simple-ios:

Значение, указывающее, какой язык должен использоваться программой чтения с экрана при взаимодействии пользователя с элементом. Оно должно соответствовать [спецификации BCP 47](https://www.rfc-editor.org/info/bcp47).

Дополнительную информацию см. в [iOS `accessibilityLanguage` doc](https://developer.apple.com/documentation/objectivec/nsobject/1615192-accessibilitylanguage).

| Type   |
| ------ |
| string |

### `accessibilityLabel`

Переопределяет текст, который считывается программой чтения с экрана, когда пользователь взаимодействует с элементом. По умолчанию метка строится путем обхода всех дочерних элементов и накопления всех узлов `Text`, разделенных пробелом.

| Type   |
| ------ |
| string |

### `accessibilityRole`

Указывает программе чтения экрана рассматривать текущий элемент, на котором сосредоточено внимание, как имеющий определенную роль.

В iOS эти роли отображаются на соответствующие черты доступности. Кнопка изображения имеет ту же функциональность, что и в случае, когда для трейта установлены значения 'image' и 'button'. Дополнительную информацию см. в [Руководстве по доступности](accessibility.md#accessibilitytraits-ios).

| Type                                                 |
| ---------------------------------------------------- |
| [AccessibilityRole](accessibility#accessibilityrole) |

### `accessibilityState`

Указывает программе чтения экрана рассматривать элемент, на котором сфокусировано внимание, как находящийся в определенном состоянии.

Вы можете указать одно состояние, отсутствие состояния или несколько состояний. Состояния должны быть переданы через объект. Например: `{выбран: true, отключен: true}`.

| Type                                                   |
| ------------------------------------------------------ |
| [AccessibilityState](accessibility#accessibilitystate) |

### `accessibilityActions`

Действия доступности позволяют ассистивной технологии программно вызывать действия компонента. Свойство `accessibilityActions` должно содержать список объектов действий. Каждый объект действия должен содержать имя поля и метку.

Дополнительную информацию см. в [Руководстве по доступности](accessibility.md#accessibility-actions).

| Type  | Required |
| ----- | -------- |
| array | No       |

### `onAccessibilityAction`

Вызывается, когда пользователь выполняет действия по обеспечению доступности. Единственным аргументом этой функции является событие, содержащее имя выполняемого действия.

Дополнительную информацию см. в [Руководстве по доступности](accessibility.md#accessibility-actions).

| Type     | Required |
| -------- | -------- |
| function | No       |

### `accessible`

Если установлено значение `true`, указывает, что представление является элементом доступности.

Дополнительную информацию см. в [Руководстве по доступности](accessibility#accessible-ios-android).

| Type    | Default |
| ------- | ------- |
| boolean | `true`  |

### `adjustsFontSizeToFit`

Указывает, следует ли автоматически уменьшать масштаб шрифтов для соответствия заданным стилевым ограничениям.

| Type    | Default |
| ------- | ------- |
| boolean | `false` |

### `allowFontScaling`

Указывает, должны ли шрифты масштабироваться с учетом настроек доступности Text Size.

| Type    | Default |
| ------- | ------- |
| boolean | `true`  |

### `android_hyphenationFrequency` :simple-android:

Устанавливает частоту использования автоматического дефиса при определении разрыва слов на Android API Level 23+.

| Type                                | Default  |
| ----------------------------------- | -------- |
| enum(`'none'`, `'normal'`,`'full'`) | `'none'` |

### `aria-busy`

Указывает на то, что элемент изменяется и что вспомогательные технологии могут захотеть подождать, пока изменения не будут завершены, прежде чем информировать пользователя об обновлении.

| Type    | Default |
| ------- | ------- |
| boolean | false   |

### `aria-checked`

Указывает состояние элемента с флажком. Это поле может принимать либо булево значение, либо строку "mixed" для представления смешанных флажков.

| Type             | Default |
| ---------------- | ------- |
| boolean, 'mixed' | false   |

### `aria-disabled`

Указывает, что элемент воспринимается, но отключен, поэтому его нельзя редактировать или использовать иным образом.

| Type    | Default |
| ------- | ------- |
| boolean | false   |

### `aria-expanded`

Указывает, является ли расширяемый элемент в данный момент развернутым или свернутым.

| Type    | Default |
| ------- | ------- |
| boolean | false   |

### `aria-label`

Определяет строковое значение, которое маркирует интерактивный элемент.

| Type   |
| ------ |
| string |

### `aria-selected`

Указывает, выбран ли выбираемый элемент в данный момент или нет.

| Type    |
| ------- |
| boolean |

### `dataDetectorType` :simple-android:

Определяет типы данных, преобразуемых в кликабельные URL-адреса в текстовом элементе. По умолчанию типы данных не определяются.

Вы можете указать только один тип.

| Type                                                          | Default  |
| ------------------------------------------------------------- | -------- |
| enum(`'phoneNumber'`, `'link'`, `'email'`, `'none'`, `'all'`) | `'none'` |

### `disabled` :simple-android:

Указывает отключенное состояние текстового представления для целей тестирования.

| Type | Default |
| ---- | ------- |
| bool | `false` |

### `dynamicTypeRamp` :simple-ios:

Рампа [Dynamic Type](https://developer.apple.com/documentation/uikit/uifont/scaling_fonts_automatically), применяемая к этому элементу на iOS.

| Type                                                                                                                                                     | Default  |
| -------------------------------------------------------------------------------------------------------------------------------------------------------- | -------- |
| enum(`'caption2'`, `'caption1'`, `'footnote'`, `'subheadline'`, `'callout'`, `'body'`, `'headline'`, `'title3'`, `'title2'`, `'title1'`, `'largeTitle'`) | `'body'` |

### `ellipsizeMode`

Когда задано `numberOfLines`, этот реквизит определяет, как будет усечен текст. `numberOfLines` должен быть установлен в сочетании с этим реквизитом.

Это может быть одно из следующих значений:

-   `head` — Строка отображается так, чтобы конец помещался в контейнер, а отсутствующий текст в начале строки обозначается глифом многоточия. например, "...wxyz".
-   `middle` — строка отображается так, что начало и конец помещаются в контейнер, а отсутствующий текст в середине обозначается глифом многоточия. "ab...yz"
-   `tail` — Строка отображается так, что начало помещается в контейнер, а пропущенный текст в конце строки обозначается многоточием. например, "abcd...".
-   `clip` — Линии не выводятся за край текстового контейнера.

!!!warning ""

    На Android, когда `numberOfLines` установлено в значение больше, чем `1`, корректно работает только значение `tail`.

| Type                                           | Default |
| ---------------------------------------------- | ------- |
| enum(`'head'`, `'middle'`, `'tail'`, `'clip'`) | `tail`  |

### `id`

Используется для определения местоположения этого представления из нативного кода. Имеет приоритет над реквизитом `nativeID`.

| Type   |
| ------ |
| string |

### `maxFontSizeMultiplier`

Определяет наибольший возможный масштаб, которого может достичь шрифт, если включено `allowFontScaling`. Возможные значения:

-   `null/undefined`: наследование от родительского узла или глобального значения по умолчанию (0)
-   `0`: нет максимального значения, игнорировать родительское/глобальное значение по умолчанию
-   `>= 1`: устанавливает `maxFontSizeMultiplier` этого узла в данное значение

| Type   | Default     |
| ------ | ----------- |
| number | `undefined` |

### `minimumFontScale` :simple-ios:

Определяет наименьший возможный масштаб, которого может достичь шрифт, когда включена функция `adjustsFontSizeToFit`. (значения 0.01-1.0).

| Type   |
| ------ |
| number |

### `nativeID`

Используется для определения местоположения этого представления из нативного кода.

| Type   |
| ------ |
| string |

### `numberOfLines`

Используется для усечения текста многоточием после вычисления расположения текста, включая обводку строк, таким образом, чтобы общее количество строк не превышало данного числа. Установка этого свойства в `0` приведет к снятию этого значения, что означает, что ограничение на количество строк применяться не будет.

Этот параметр обычно используется с `ellipsizeMode`.

| Type   | Default |
| ------ | ------- |
| number | `0`     |

### `onLayout`

Вызывается при монтировании и при смене раскладки.

| Type                                                   |
| ------------------------------------------------------ |
| ({nativeEvent: [LayoutEvent](layoutevent.md)}) => void |

### `onLongPress`

Эта функция вызывается при длительном нажатии.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onMoveShouldSetResponder`

Хочет ли это представление "претендовать" на отзывчивость на прикосновение? Это вызывается для каждого движения прикосновения к `View`, когда он не является ответчиком.

| Type                                                    |
| ------------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => boolean |

### `onPress`

Функция, вызываемая при нажатии кнопки пользователем, срабатывает после `onPressOut`.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onPressIn`

Вызывается сразу же при задействовании касания, перед `onPressOut` и `onPress`.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onPressOut`

Вызывается, когда прикосновение отпускается.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onResponderGrant`

Представление теперь реагирует на события прикосновения. Сейчас самое время выделить и показать пользователю, что происходит.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onResponderMove`

Пользователь перемещает свой палец.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onResponderRelease`

Уволен в конце касания.

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

Ответчик был забран из `View`. Может быть взят другими представлениями после вызова `onResponderTerminationRequest`, или может быть взят ОС без запроса (например, происходит с центром управления/центром уведомлений на iOS).

| Type                                                 |
| ---------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => void |

### `onResponderTerminationRequest`

Какой-то другой `View` хочет стать отвечающим и просит этот `View` освободить его отвечающего. Возврат `true` позволяет освободить его.

| Type                                                    |
| ------------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => boolean |

### `onStartShouldSetResponderCapture`

Если родительский `View` хочет предотвратить превращение дочернего `View` в ответчика при запуске касания, он должен иметь этот обработчик, который возвращает `true`.

| Type                                                    |
| ------------------------------------------------------- |
| ({nativeEvent: [PressEvent](pressevent.md)}) => boolean |

### `onTextLayout`

Вызывается при изменении макета текста.

| Type                                                    |
| ------------------------------------------------------- |
| ([`TextLayoutEvent`](text.md#textlayoutevent)) => mixed |

### `pressRetentionOffset`

Когда вид прокрутки отключен, этот параметр определяет, насколько далеко ваше прикосновение может отойти от кнопки, прежде чем кнопка будет деактивирована. После деактивации попробуйте переместить ее обратно, и вы увидите, что кнопка снова активирована! Переместите ее вперед-назад несколько раз, пока вид прокрутки отключен. Убедитесь, что вы передаете константу, чтобы уменьшить выделение памяти.

| Type                    |
| ----------------------- |
| [Rect](rect.md), number |

### `role`

`role` передает назначение компонента пользователю вспомогательной технологии. Имеет приоритет над реквизитом [`accessibilityRole`](text.md#accessibilityrole).

| Type                          |
| ----------------------------- |
| [Role](accessibility.md#role) |

### `selectable`

Позволяет пользователю выбрать текст, чтобы использовать встроенную функцию копирования и вставки.

| Type    | Default |
| ------- | ------- |
| boolean | `false` |

### `selectionColor` :simple-android:

Цвет выделения текста.

| Type               |
| ------------------ |
| [color](colors.md) |

### `style`

| Type                                                                       |
| -------------------------------------------------------------------------- |
| [Text Style](text-style-props.md), [View Style Props](view-style-props.md) |

### `suppressHighlighting` :simple-ios:

Если `true`, то при нажатии на текст не происходит никаких визуальных изменений. По умолчанию при нажатии на текст выделяется серый овал.

| Type    | Default |
| ------- | ------- |
| boolean | `false` |

### `testID`

Используется для размещения этого представления в сквозных тестах.

| Type   |
| ------ |
| string |

### `textBreakStrategy` :simple-android:

Установка стратегии разбиения текста на Android API Level 23+, возможные значения `simple`, `highQuality`, `balanced`.

| Type                                            | Default       |
| ----------------------------------------------- | ------------- |
| enum(`'simple'`, `'highQuality'`, `'balanced'`) | `highQuality` |

### `userSelect`

Позволяет пользователю выделять текст и использовать встроенные функции копирования и вставки. Имеет приоритет перед реквизитом `selectable`.

| Type                                                     | Default |
| -------------------------------------------------------- | ------- |
| enum(`'auto'`, `'text'`, `'none'`, `'contain'`, `'all'`) | `none`  |

### `lineBreakStrategyIOS` :simple-ios:

Установка стратегии перевода строки на iOS 14+. Возможные значения: `none`, `standard`, `hangul-word` и `push-out`.

| Type                                                        | Default  |
| ----------------------------------------------------------- | -------- |
| enum(`'none'`, `'standard'`, `'hangul-word'`, `'push-out'`) | `'none'` |

## Определения типа

### TextLayout

Объект `TextLayout` является частью обратного вызова [`TextLayoutEvent`](text.md#textlayoutevent) и содержит данные измерения для строки `Text`.

#### Пример

```js
{
    capHeight: 10.496,
    ascender: 14.624,
    descender: 4,
    width: 28.224,
    height: 18.624,
    xHeight: 6.048,
    x: 0,
    y: 0
}
```

#### Свойства

| Name      | Type   | Optional | Description                                                         |
| --------- | ------ | -------- | ------------------------------------------------------------------- |
| ascender  | number | No       | The line ascender height after the text layout changes.             |
| capHeight | number | No       | Height of capital letter above the baseline.                        |
| descender | number | No       | The line descender height after the text layout changes.            |
| height    | number | No       | Height of the line after the text layout changes.                   |
| width     | number | No       | Width of the line after the text layout changes.                    |
| x         | number | No       | Line X coordinate inside the Text component.                        |
| xHeight   | number | No       | Distance between the baseline and median of the line (corpus size). |
| y         | number | No       | Line Y coordinate inside the Text component.                        |

### TextLayoutEvent

Объект `TextLayoutEvent` возвращается в обратном вызове в результате изменения компоновки компонента. Он содержит ключ `lines` со значением, которое представляет собой массив, содержащий объект [`TextLayout`](text.md#textlayout), соответствующий каждой отрисованной строке текста.

#### Пример

```js
{
    lines: [
        TextLayout,
        TextLayout,
        // ...
    ];
    target: 1127;
}
```

#### Свойства

| Name   | Type                                    | Optional | Description                                           |
| ------ | --------------------------------------- | -------- | ----------------------------------------------------- |
| lines  | array of [TextLayout](text#textlayout)s | No       | Provides the TextLayout data for every rendered line. |
| target | number                                  | No       | The node id of the element.                           |
