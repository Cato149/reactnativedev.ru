# Почему новая архитектура

!!!warning "Внимание"

    Эта документация все еще является **экспериментальной**, и детали могут быть изменены по мере итераций. Не стесняйтесь делиться своими отзывами в [обсуждении внутри рабочей группы](https://github.com/reactwg/react-native-new-architecture/discussions/8) для этой страницы.

    Более того, она содержит несколько **ручных шагов**. Пожалуйста, обратите внимание, что это не будет представлять окончательный опыт разработчиков, когда Новая архитектура станет стабильной. Мы работаем над инструментами, шаблонами и библиотеками, которые помогут вам быстро начать работу с новой архитектурой без необходимости проходить всю процедуру настройки.

Цель новой архитектуры — решить некоторые проблемы, которые были характерны для старой архитектуры с точки зрения производительности и гибкости. Этот раздел предоставляет базовый контекст для понимания ограничений старой архитектуры и того, как их удалось преодолеть с помощью новой архитектуры.

Это не техническое углубление: за более подробной технической информацией обращайтесь к вкладке [Architecture](architecture-overview.md) сайта.

## Проблемы старой архитектуры

Старая архитектура работала путем сериализации всех данных, которые должны были быть переданы от JS слоя к нативному слою с помощью компонента под названием _The Bridge_. _The Bridge_ можно представить как шину, по которой уровень производителя отправляет некоторые данные для уровня потребителя. Потребитель мог прочитать данные, десериализовать их и выполнить необходимые операции.

У _Моста_ были некоторые внутренние ограничения:

-   **Он был асинхронным:** один слой отправлял данные на мост и асинхронно "ждал", пока другой слой их обработает, даже когда в этом не было необходимости.
-   **Он был однопоточным:** JS работал в одном потоке; поэтому вычисления, которые происходили в этом мире, должны были выполняться в этом единственном потоке.
-   **Это накладывало дополнительные накладные расходы:** каждый раз, когда один слой должен был использовать другой слой, он должен был сериализовать некоторые данные. Другой слой должен был десериализовать их. Был выбран формат JSON за его простоту и человекочитаемость, но, несмотря на легкость, за это пришлось заплатить.

## Усовершенствования новой архитектуры

Новая архитектура отказалась от концепции _The Bridge_ в пользу другого механизма коммуникации: _JavaScript Interface (JSI)_. Интерфейс _JSI_ позволяет объекту JavaScript хранить ссылку на C++ и наоборот.

Как только объект получает ссылку на другой объект, он может напрямую вызывать его методы. Так, например, объект C++ теперь может попросить объект JavaScript выполнить метод в мире JavaScript и наоборот.

Эта идея позволила раскрыть несколько преимуществ:

-   **Синхронное выполнение:** теперь можно синхронно выполнять те функции, которые изначально не должны были быть асинхронными.
-   **Валютность:** из JavaScript можно вызывать функции, которые выполняются в разных потоках.
-   **Меньшие накладные расходы:** новой архитектуре больше не нужно сериализовать/десериализовать данные, поэтому нет необходимости платить налоги за сериализацию.
-   **Обмен кодом:** благодаря внедрению C++, теперь можно абстрагировать весь код, не зависящий от платформы, и с легкостью обмениваться им между платформами.
-   **Типовая безопасность:** чтобы убедиться, что JS может правильно вызывать методы на объектах C++ и наоборот, был добавлен слой автоматически генерируемого кода. Код генерируется, начиная с некоторой спецификации JS, которая должна быть типизирована через Flow или TypeScript.

Эти преимущества являются основой [New Native Module System](the-new-architecture-pillars-turbomodules.md) и трамплином для дальнейших улучшений. Например, удалось разработать [новый рендерер](fabric-renderer.md), который предлагает более быстрые и производительные [нативные компоненты](the-new-architecture-pillars-fabric-components.md).

## Дальнейшее чтение

Технический обзор новой архитектуры можно найти на вкладке [Architecture](architecture-overview.md).

Для получения дополнительной информации о Fabric Renderer читайте раздел [Fabric](fabric-renderer.md).
